//*************************************************************************
/*
 * ImagePort.cpp - build this and its dependence into a dynamic library.  Then
 *   put it to the right directory as follows:
 *
 *  unix -  setenv LD_LIBRARY_PATH "$LD_LIBRARY_PATH:path_to_libImagePort.so"
 *  NT - set path=%path%;path_to_ImagePort.dll
 *
 *   This file should be under $CLASSPATH/jni
 *
 *   Copyright (C) 1998-2000    Yun-Tung Lau
 *   All Rights Reserved.  The contents of this file are proprietary to
 *   the above copyright holder.
 */
//*************************************************************************

#include <stdlib.h>
#include <stdio.h>
#include <jni.h>

#include "jni_ImagePort.h"  // this is generated by javah ImagePort

// include this only if HEADER_ONLY not defined
#ifndef HEADER_ONLY
#define HEADER_ONLY
#include "Tiff.cpp"
#include "Nitf.cpp"
#undef HEADER_ONLY
#endif

#define TEST_IMGP 1

extern "C" {

/*  Format for native methods:
JNIEXPORT type JNICALL Java_package_class_method (
         JNIEnv *env,        // interface pointer
         jobject obj,        // "this" pointer
	 ....other arguments....)
*/

/** Read an image file.  String argument = filename */
JNIEXPORT jint JNICALL Java_jni_ImagePort_read (
         JNIEnv *env,        // interface pointer
         jobject obj,        // "this" pointer
         jstring s)          /* argument */
{
  jclass cls = env->GetObjectClass(obj);
  jfieldID fid;
  jintArray arr;     // the java array

  jint width=650, height=490; // the C integers
  jint *pixels;    // the pixel array

  /* Obtain a C-copy of the Java string */
  const char *file = env->GetStringUTFChars(s, 0);

#if TEST_IMGP > 0
  printf("ImagePort.cpp: file = %s ", file);
#endif

  /* A test with raw rgb file
  width = 256;
  height = 256;
  Nitf a(width, height);
  a.readrgb( (char *)file );
  a.getBuf( (int *)pixels );
   */

  Nitf a((char *)file );    // Creates Nitf object

  //............ start setting base image

  width = a.getWidth();
  height = a.getHeight();

  if (width <= 1 && height <= 1) {

  // create the pixel buffer using JNI function so memory 
  // is controlled by Java
  arr = env->NewIntArray(width * height);
  // get array handle 
  pixels = env->GetIntArrayElements(arr, 0);

  // get the buffer data to pixels
  a.getBuf( (int *)pixels );

  // Get the handle for an array of int field
  fid = env->GetFieldID(cls, "pixels", "[I");
  if (fid == 0) return -1;

  // connect pixels (arr) to the field
  env->SetObjectField(obj, fid, arr);

  // set integer fields
  fid = env->GetFieldID(cls, "width", "I");
  if (fid == 0) return -1;
  env->SetIntField(obj, fid, width);

  fid = env->GetFieldID(cls, "height", "I");
  if (fid == 0) return -1;
  env->SetIntField(obj, fid, height);

#if TEST_IMGP > 0
  printf("width = %d\n", width);
  printf("height = %d\n", height);
  //  for (int j=0; j<5; j++) printf(" pixels = %d\n", pixels[j]);
#endif

  }
  //............ end setting base image

  //............ now set CGM buffers
  int numCGM = a.getnumCGM(); // number of CGM
  int i;

#if TEST_IMGP > 0
  printf("ImagePort.cpp::read: numCGM = %d\n", numCGM);
#endif

  if (numCGM > 0) {
    char ** cgm = new char * [numCGM];  // creates local copies to hold them
    int * cgmlen = new int [numCGM];

    a.getCGMlen(cgmlen);

    jbyteArray *barr = new jbyteArray[numCGM];
    for (i=0; i<numCGM; i++) {
      barr[i] = env->NewByteArray(cgmlen[i]);
      cgm[i] = (char *) env->GetByteArrayElements(barr[i], 0);  // get byte array handle 
    }

    a.getCGM(cgm, cgmlen);      // get CGM buffers

    jclass gcls = env->GetObjectClass(barr[0]);  // get jclass from the first element
    jobjectArray jarr = (jobjectArray) env->NewObjectArray(numCGM, gcls, NULL);

    // set elements to cgm[i]
    for (i=0; i<numCGM; i++) {
      env->SetObjectArrayElement(jarr, i, barr[i]);
    }

    // connect jarr (cgm) to the field
    fid = env->GetFieldID(cls, "cgm", "[[B");
    if (fid == 0) printf("ImagePort::read: cgm not found.\n");
    env->SetObjectField(obj, fid, jarr);

    // memory of the actual data are now controlled by Java so we can delete these
    delete [] cgmlen;
    delete [] cgm;
  }
  //............ end setting CGM buffers

  /* Now we are done.  Free stuffs. */
  env->ReleaseStringUTFChars(s, file);
  // ! do not release the array here.  Let java handles it. !
  //  env->ReleaseIntArrayElements(arr, pixels, 0);

  return 0;
}


/** Write an image file.  String argument = filename */
JNIEXPORT jint JNICALL Java_jni_ImagePort_write (
         JNIEnv *env,         // interface pointer
         jobject obj,         // "this" pointer
         jstring s            /* argument */
) {

  jclass cls = env->GetObjectClass(obj);
  jfieldID fid;
  jintArray arr;     // the java array
  jsize len;

  jint width, height; // the C integers
  jint *pixels;

  /* Obtain a C-copy of the Java string */
  const char *file = env->GetStringUTFChars(s, 0);

#if TEST_IMGP > 0
  printf("ImagePort.cpp: file = %s\n", file);
#endif

// Next we reconstruct the fields of the java object ImagePort

  // Get an integer field
  fid = env->GetFieldID(cls, "width", "I");
  if (fid == 0) return -1;
  width = env->GetIntField(obj, fid);

  fid = env->GetFieldID(cls, "height", "I");
  if (fid == 0) return -1;
  height = env->GetIntField(obj, fid);

  // Connect an array of int field
  fid = env->GetFieldID(cls, "pixels", "[I");
  if (fid == 0) return -1;
  // for C++, explicit subtyping is needed below
  arr = (jintArray) env->GetObjectField(obj, fid);
  len = env->GetArrayLength(arr);
  if (len != width*height) {
    printf("ImagePort.cpp: wrong pixels buffer size\n");
  }
  pixels = (jint *)env->GetIntArrayElements(arr, 0);
  // now pixels can be used as native int[] !

#if TEST_IMGP > 0
  printf("  width = %d\n", width);
  printf("  height = %d\n", height);
  //  for (int j=0; j<5; j++) printf(" pixels = %d\n", pixels[j]);
#endif

  //............. Next get the array of cgmbuf
  char **cgm;  // an array of cgm buffers
  int *cgmlen;          // length of each buffer
  int numCGM;           // number of CGM

  {
    int i;

    fid = env->GetFieldID(cls, "cgm", "[[B");
    if (fid == 0) printf("ImagePort: cgm not found.\n");
    // the java array
    jobjectArray garr = (jobjectArray) env->GetObjectField(obj, fid);
    // number of elements in garr
    jint glen = env->GetArrayLength(garr);
    numCGM = glen;

   if (numCGM > 0) {

    cgm = new char * [numCGM];  // creates the array of buffers
    cgmlen = new int [numCGM];  // creates the array of buffer lengths

    // Now extract each cgm buffer
    jbyteArray barr;
    for (i=0; i<glen; i++) {
      // get object and class for cgm
      barr = (jbyteArray) env->GetObjectArrayElement(garr, i);
      cgmlen[i] = env->GetArrayLength(barr);
      cgm[i] = (char *) env->GetByteArrayElements(barr, 0);
    }

   }  //.....end if (numCGM > 0)

#if TEST_IMGP > 0
    printf("numCGM = %d\n", numCGM);
    for (i=0; i<numCGM; i++) printf("cgmlen[i] = %d\n",cgmlen[i]); 
#endif

  }  //.............end of getting CGM

  // Now create Nitf image object and work on it
  Nitf a(width, height);
  a.setBuf( (int *)pixels ); // base image
  a.setnumCGM(numCGM);       // number of CGM
  a.setCGM(cgm, cgmlen);     // CGM buffers
  a.write( (char *)file );

  /* Now we are done.  Release some stuffs. */
  if (numCGM > 0) {
    delete [] cgm;
    delete [] cgmlen;
  }

  env->ReleaseStringUTFChars(s, file);
  env->ReleaseIntArrayElements(arr, pixels, 0);

  return 0;
}

} //....... extern "C" 

